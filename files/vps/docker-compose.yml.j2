# {{ ansible_managed }}

networks:
  default:
    driver: bridge
    ipam:
      config:
        - subnet: {{ vps_docker_network_subnet }}
          gateway: {{ vps_docker_network_gateway }}


services:
  ### Utils ###
  whoami:
    image: traefik/whoami
    container_name: whoami
    ports:
      - "5000:80"
    restart: unless-stopped

  ## Networking ##
  duckdns:
    image: linuxserver/duckdns:latest
    container_name: duckdns
    environment:
      TZ: {{ timezone }}
      SUBDOMAINS: {{ vps_duckdns_subdomain }}
      TOKEN: {{ duckdns_token }}
      LOG_FILE: true
    restart: unless-stopped

  wireguard:
    image: linuxserver/wireguard:latest
    container_name: wireguard
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    environment:
      PUID: 1000
      PGID: 1000
      TZ: {{ timezone }}
      SERVERURL: wireguard.{{ vps_duckdns_subdomain }}.duckdns.org
      SERVERPORT: 51820
      INTERNAL_SUBNET: {{ vpn_network_subnet }}
    volumes:
      - {{ containers_setup_configs_dir }}/server-wg0.conf:/config/wg_confs/server_wg0.conf:ro
      - /lib/modules:/lib/modules
    ports:
      - "51820:51820/udp"
      # - "5000:5000"  # for wireguard-ui, set here as network_mode: service:wireguard
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
      - net.ipv4.ip_forward=1
    healthcheck:
      test: ["CMD", "wg", "show", "server_wg0"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # TODO: thing about unbound to resolve DNS and not send it to the google etc
  pihole:
    image: pihole/pihole:latest
    container_name: pihole
    environment:
      PIHOLE_UID: 1000
      PIHOLE_GID: 1000
      TZ: {{ timezone }}
      WEBPASSWORD: password  # for http://pi.hole/admin
      PIHOLE_DNS_: "1.1.1.1;8.8.8.8"
      DNSMASQ_LISTENING: "local"
      WEBTHEME: default-dark
      FTLCONF_LOCAL_IPV4: "{{ local_ipv4 }}"
    ports:
      - "53:53/tcp"
      - "53:53/udp"
      - "8053:80/tcp"  # custom port for web interface
    volumes:
      - {{ containers_setup_configs_dir }}/pihole/:/etc/pihole/:rw
      - {{ containers_setup_configs_dir }}/pihole-dnsmasq.d:/etc/dnsmasq.d/:rw
    networks:
      default:
        ipv4_address: {{ vps_docker_network_pihole_ip }}
    healthcheck:
      test: ["CMD", "dig", "+norecurse", "+retry=0", "@127.0.0.1", "pi.hole"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  traefik:
    image: traefik:v3.5
    container_name: traefik
    command:
      - --providers.docker=true
      - --providers.docker.endpoint=unix:///var/run/docker.sock
      - --providers.docker.exposedbydefault=false
      - --providers.docker.watch=true
{#      - --providers.docker.network={{ vps_docker_network_name }}#}
      # entrypoints
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.ping.address=:8082
      # HTTP to HTTPS redirect (but allow ACME challenges)
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
      - --entrypoints.web.http.redirections.entrypoint.priority=1
      # ACME (Let's Encrypt) - HTTP-01 (no email set; optional)
      - --certificatesresolvers.lehttp.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.lehttp.acme.httpchallenge.entrypoint=web
      # ping
      - --ping=true
      - --ping.entrypoint=ping
      # (optional) dashboard (secure behind your VPN if you expose 8080)
      - --api.dashboard=true
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"  # optional dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - {{ containers_setup_data_dir }}/traefik-letsencrypt:/letsencrypt
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O- http://127.0.0.1:8082/ping >/dev/null || exit 1"]
{#      test: ["CMD", "traefik", "healthcheck", "--ping=true", "--ping.entrypoint=ping"]#}
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  ### Games ###
  foundryvtt:
    image: felddy/foundryvtt:release
    container_name: foundryvtt
    environment:
      PUID: 1000
      PGID: 1000
      TZ: {{ timezone }}
      FOUNDRY_MINIFY_STATIC_FILES: "true"
      FOUNDRY_COMPRESS_WEBSOCKET: "true"
      FOUNDRY_PROXY_SSL: "true"            # behind TLS-terminating proxy
      FOUNDRY_PROXY_PORT: 443              # external port the clients hit
      FOUNDRY_HOSTNAME: "foundry.{{ vps_duckdns_subdomain }}.duckdns.org"
      CONTAINER_PRESERVE_CONFIG: "true"
      FOUNDRY_USERNAME: "{{ foundry_username }}"
      FOUNDRY_PASSWORD: "{{ foundry_password }}"
      FOUNDRY_ADMIN_KEY: "{{ foundry_admin_password }}"
    volumes:
      - {{ containers_setup_data_dir }}/foundryvtt:/data
    labels:
      - traefik.enable=true
      # service (backend) → Foundry on :30000 inside the container
      - traefik.http.services.foundry.loadbalancer.server.port=30000
      # router → subdomain host
      - traefik.http.routers.foundry.rule=Host(`foundry.{{ vps_duckdns_subdomain }}.duckdns.org`)
      - traefik.http.routers.foundry.entrypoints=websecure
      - traefik.http.routers.foundry.tls=true
      - traefik.http.routers.foundry.tls.certresolver=lehttp
      - traefik.http.routers.foundry.service=foundry
    ports:
      - "30000:30000"
    healthcheck:
      test: ["CMD", "node", "-e",
        "const http=require('http');\
const req=http.request({host:'127.0.0.1',port:30000,path:'/',timeout:2000},res=>{process.exit(res.statusCode<500?0:1)});\
req.on('timeout',()=>{req.destroy();process.exit(1)});\
req.on('error',()=>process.exit(1));\
req.end();"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 120s
    restart: unless-stopped

  ### Metrics ###
  node-exporter:
    image: prom/node-exporter:latest
    container_name: node-exporter
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    restart: unless-stopped

  cadvisor:
    image: gcr.io/cadvisor/cadvisor:v0.49.1
    container_name: cadvisor
    ports:
      - "8081:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    # healthcheck: included in the image
    restart: unless-stopped
